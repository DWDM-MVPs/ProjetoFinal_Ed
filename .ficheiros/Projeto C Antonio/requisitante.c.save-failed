#ifndef REQ_H
#define REQ_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <string.h>
#include <locale.h>
#include <ctype.h>
#include "lista.h"
#include "hashing.h"



/** ---------- CRIAR REQUISITANTE ---------- */

REQUISITANTE *criarReq()
{
    REQUISITANTE *aux = (REQUISITANTE *)malloc(sizeof(REQUISITANTE));
    aux->requisicao = NULL;
    return aux;
}

/** ---------- SOMAR OS 8 DIGITOS DE UM DADO NUMERO ---------- */

int somarDigitos(int num)
{
    if(!num)
    {
        printf("\n>> Ocorreu um erro na leitura do número\n");
        return 0;
    }

    int i, soma = 0;

    for(i = 0; i < 9; i++)
    {
      soma +=  num % 10;
      num = num / 10;
    }
    return soma;
}

/** ---------- DEVOLVE O PROXIMO MULTIPLO DE 10 DE UM DADO NUMERO ---------- */

int devolveProxMultiplo(int num)
{
    if(!num)
    {
        printf("\n>> Ocorreu um erro na leitura do número\n");
        return 0;
    }

    int soma;

    soma = somarDigitos(num + 1);

    while(soma % 10 != 0)
    {
        num++;
        soma = somarDigitos(num);
    }
    return num;
}

/** ---------- PREENCHER REQUISITANTE ---------- */

int preencherReq(REQUISITANTE *req, int ultimoId)
{
    if(!req)
    {
        printf("\n>>O requisitante não existe\n");
        return 0;
    }

    if(!ultimoId)
    {
        printf("\n>> Ocorreu um erro na leitura do ultimo ID\n");
        return 0;
    }

    printf("\n\n--------------------------------------------------");
    printf("\n-          Registo do novo requisitante          -");
    printf("\n--------------------------------------------------");

    char stringNome[100];
    char temp;

    /* Pedir o nome do requisitante */

    printf("\n\n>> Nome: ");
    scanf("%c",&temp);
    scanf("%[^\n]", stringNome); /* Poder ler nomes com espaços */

    req->nome = (char *)malloc((strlen(stringNome) + 1) * sizeof(char));
    strcpy(req->nome, stringNome);

    char data[40];
    char numDistString[7];
    char numConcString[3];

    /* Pedir e validar a data de nascimento do requisitante */

    do
    {
        printf("\n>> Data de nascimento: ");

        printf("\n\n\t>> Dia: ");
        scanf("%02d", &(req->diaNasc));

        printf("\n\t>> Mês: ");
        scanf("%02d", &(req->mesNasc));

        printf("\n\t>> Ano: ");
        scanf("%d", &(req->anoNasc));

        sprintf(data, "%d-%d-%d", req->diaNasc, req->mesNasc, req->anoNasc);

    } while(validarDataNasc(data) == 0);

    char idFreg[7];

    /* Pedir e validar o ID de freguesia do requisitante */

    do
    {
        /* Pedir o distrito */

        listarDist();

        printf("\n>> Local de residencia:\n");

        int numDist, numConc, numFreg;

        do
        {
            printf("\n\t>> Distrito: ");
            scanf("%02d", &numDist);

        }while(numDist < 1 || numDist > 18);

        /* Pedir o concelho */

        sprintf(numDistString, "%02d", numDist);

        listarConc(numDistString);

        printf("\n\t>> Concelho: ");
        scanf("%02d", &numConc);

        /* Pedir a freguesia */

        sprintf(numConcString, "%02d", numConc);
        strcat(numDistString, numConcString);

        listarFreg(numDistString);

        printf("\n\t>> Freguesia: ");
        scanf("%02d", &numFreg);

        sprintf(idFreg, "%02d%02d%02d", numDist, numConc, numFreg);

        strcpy((req->idFreguesia), idFreg);

    } while(validarIDFreg(idFreg, "Freguesias.txt") == 0);

    /* Criar um novo ID para o requisitante */

    char idReqString[10];

    ultimoId = devolveProxMultiplo(ultimoId); /* Calcula o próximo ID que corresponde aos requisitos */

    sprintf(idReqString, "%09d", ultimoId);
    strcpy(req->id, idReqString);

    return ultimoId;
}

/** ---------- MOSTRAR OS DADOS DE UM REQUISITANTE ---------- */

void mostrarReq(REQUISITANTE *req)
{
    if(!req)
    {
        printf("O requisitante não existe.");
        return;
    }

    printf("\n\n--------------------------------------------------");
    printf("\n          Requisitante Nº %s", req->id);
    printf("\n--------------------------------------------------");

    printf("\n\n- Nome: %s", req->nome);

    printf("\n\n- Data de nascimento: %02d/%02d/%04d", req->diaNasc, req->mesNasc, req->anoNasc);

    printf("\n\n- ID freguesia: %s", req->idFreguesia);
}

/** ---------- MOSTRAR A LISTA DE REQUISITANTES ---------- */

void mostrarListaReq(LISTA *lista)
{
    NODO *nodo = lista->inicio;
    int cont = 0;

    while(nodo)
    {
        REQUISITANTE *dados = nodo->info;
        mostrarReq(dados);
        nodo = nodo->seg;
        cont++;
    }
}

/** ---------- DEVOLVER O NUMERO DE REQUISITANTES NA LISTA ---------- */

int contaReq(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.");
        return;
    }

    NODO_HASHING *nodoHashing = hashingDist->inicio;
    int contador = 0;

    while(nodoHashing)
    {
        NODO *nodo = nodoHashing->lista->inicio;

        while(nodo)
        {
            contador++;
            nodo = nodo->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return contador;
}

/** ---------- CONCATENAR DOIS INTEGERS ---------- */

int concatInteger(int a, int b)
{

    char s1[20];
    char s2[20];

    // Convert both the integers to string
    sprintf(s1, "%02d", a);
    sprintf(s2, "%02d", b);

    // Concatenate both strings
    strcat(s1, s2);

    // Convert the concatenated string
    // to integer
    int c = atoi(s1);

    // return the formed integer
    return c;
}

/** ---------- CALCULAR A IDADE DE UM DADO REQUISITANTE ---------- */

int calcularIdade(REQUISITANTE *req)
{
    time_t tempo = time(NULL);
    struct tm tm = *localtime(&tempo);

    int ano = tm.tm_year + 1900;
    int mes = tm.tm_mon + 1;
    int dia = tm.tm_mday;
    int idade;

    if(!req)
    {
        printf("O requisitante não existe.");
        return;
    }


    if(mes < req->mesNasc) /* Neste caso, o requisitante ainda não fez anos */
    {
        idade = ano - req->anoNasc - 1;
        return idade;
    }

    else /* Neste caso, o requisitante nasceu antes do mês atual, ou neste mês */
    {
        if(mes == req->mesNasc) /* O requisitante vai fazer anos este mês, devemos conhecer o dia */
        {
            if(dia < req->diaNasc) /* Neste caso, o requisitante nasceu depois do dia de hoje (ainda não fez anos)  */
            {
                idade = ano - req->anoNasc - 1;
                return idade;
            }
        }
        idade = ano - req->anoNasc; /* O requisitante nasceu antes do mês atual */
        return idade;
    }
}

/** ---------- DETERMINAR A IDADE MAXIMA DE TODOS OS REQUISITANTES ---------- */

REQUISITANTE *idadeMax(HASHING *hashingDist)
{
    int max = 0;

    if(!hashingDist)
    {
        printf("O hashing de distritos não existe.");
        return NULL;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return NULL;
    }

    NODO_HASHING *nodoHashing = hashingDist->inicio;
    REQUISITANTE *req;

    while(nodoHashing) /* Enquanto existir distritos */
    {
        NODO *aux = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante daquele distrito */

        while(aux) /* Enquanto existir requisitantes naquele distrito */
        {
            int idade = calcularIdade((REQUISITANTE *)aux->info);

            if (idade > max)
            {
                max = idade;
                req = (REQUISITANTE *)aux->info;
            }
            aux = aux->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return req;
}

/** ---------- DETERMINAR A IDADE MEDIA DE TODOS OS REQUISITANTES ---------- */

int idadeMedia(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("O hashing de distritos não existe.");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return 0;
    }

    NODO_HASHING *nodoHahing = hashingDist->inicio;
    int totalReq = 0, media = 0;
    float soma = 0.0;

    while(nodoHahing) /* Enquanto houver distritos */
    {
        NODO *aux = nodoHahing->lista->inicio; /* Bscar o primeiro requisitante da cidade */

        while(aux) /* Enquanto houver requisitantes naquele distrito */
        {
            int idadeReq = calcularIdade((REQUISITANTE *)aux->info);
            soma += idadeReq;
            totalReq++;
            aux = aux->seg; /* Requisitante seguinte */
        }
        nodoHahing = nodoHahing->seg;  /**Distrito seguinte */
    }
    media = soma / totalReq;
    return media;
}

/** ---------- DETERMINAR O NUMERO DE REQUISITANTES, QUE TÊM A IDADE > A IDADE INSERIDA PELO UTILIZADOR ---------- */

int idadeSup(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("O hashing de distritos não existe.");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return 0;
    }

    int totalReq = 0;
    int idadeLimitadora;

    do
    {
        printf("\nInsira a idade limite (exclusive): ");
        scanf("%d", &idadeLimitadora);

    }while(idadeLimitadora <= 0 || idadeLimitadora > 100);

    NODO_HASHING *nodoHashing = hashingDist->inicio;

    while(nodoHashing) /* Enquanto houver distritos */
    {
        NODO *auxReq = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante do distrito */

        while(auxReq) /* Enquanto houver requisitantes naquele distrito */
        {
            int idade = calcularIdade((REQUISITANTE *)auxReq->info);

            if (idade > idadeLimitadora)
                    totalReq++;

            auxReq = auxReq->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return totalReq;
}

/** ---------- VALIDAR O ID DE CADA REQUISITANTE ---------- */

int validarIdReq(char id[10]) /* 0: inválido / 1: válido */
{
    if(!id)
    {
        printf("\nO ID não existe.\n");
        return 0;
    }

    /* Verificar se o ID contem 9 algarismos */

    int tamanho = (int)strlen(id);

    if(tamanho != 9)
        return 0;

    /* Verificar se a soma dos 9 algarismos é um multiplo de 10 */

    int i;
    int soma = 0;

    for(i = 0; i < tamanho; i++)
        soma += (int)id[i]-'0'; /* Transformar um char em int (com o devido código ASCII) */

    if(soma % 10 == 0) /* Se o resto da soma for igual a 0, indicará a validade do ID */
        return 1;

    return 0;
}

/** ---------- VERIFICAR SE O ANO É BISSEXTO ---------- */

int bissexto(int ano)
{
    if (ano % 4 == 0)
    {
        if (ano % 100 == 0)
            return 0;
        return 1;
    }

    else
    {
        if (ano % 400 == 0)
                return 1;
        return 0;
    }
}

/** ---------- VALIDAR A DATA DE NASCIMENTO DE CADA REQUISITANTE ---------- */

int validarDataNasc(char dataNasc[40])
{
    if(!dataNasc)
    {
        printf("\nOcorreu um erro na leitura da data de nascimento.\n");
        return 0;
    }

    /* Validar o formato da data */

    int dia, mes, ano;

    int validadeFormato = sscanf(dataNasc, "%d-%d-%d", &dia, &mes, &ano);

    if(validadeFormato != 3)
        return 0;

    /* Validar o ano */

    time_t currTime = time(NULL);
    struct tm tm = *localtime(&currTime);

    int anoAtual = tm.tm_year + 1900;

    if(ano < 1900 || ano >= anoAtual)
        return 0;

    int anoBissexto = bissexto(ano); /* ESTA FUNÇÃO NÃO ESTÁ A FUNCIONAR CORRETAMENTE */

    /* Validar o mês */

    if(mes < 1 || mes > 12)
        return 0;

    /* Validar o dia, consoante o mês */

    switch(mes)
    {
        case 1:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 2:
        {
            if(anoBissexto) /* Ano bissexto */
            {
                if(dia < 1 || dia > 29)
                    return 0;
                return 1;
            }

            else /* Ano não bissexto */
            {
                if(dia < 1 || dia > 28)
                    return 0;
                return 1;
            }
            break;
        }

        case 3:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 4:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 5:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 6:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 7:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 8:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 9:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 10:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 11:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 12:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }
    }
}

/** ---------- VALIDAR O ID DA FREGUESIA DO REQUISITANTE  ---------- */

int validarIDFreg(char idFreg[7], char *nomeFic)
{
    if(!idFreg)
    {
        printf("\nOcorreu um erro na leitura do ID de freguesia.\n");
        return;
    }

    int tamanho = strlen(idFreg);

    if(tamanho != 6)
        return 0;

    FILE *fic;
    char linha[120];
    fic = fopen(nomeFic, "r");

    if(!fic)
    {
        printf("\nNão foi possível abrir o ficheiro [%s].\n", nomeFic);
        fclose(fic);
        return 0;
    }

    while(!feof(fic))
    {
        if(fgets(linha, 120, fic) != NULL) /* Verifica se  leitura foi feita com sucesso */
        {
            char *found = strstr(linha, idFreg);
            if(found != NULL)
            {
                fclose(fic);
                return 1;
            }
        }
    }
    fclose(fic);
    return 0;
}



/** ---------- VERIFICAR SE UM REQUISITANTE EXISTE, INSERINDO O NOME DELE (COMPLETO) ---------- */
/** Inseriro nome completo, é a única maneira de saber se AQUELE requisitante existe. Pois podem exisitir varios João, Maria...*/

REQUISITANTE *existeReq(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.\n");
        return NULL;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return NULL;
    }

    char nome[60];
    char temp;

    printf("\n- Nome do requisitante: ");
    scanf("%c",&temp);
    scanf("%[^\n]", nome);

    NODO_HASHING *nodoHashing = hashingDist->inicio;

    while(nodoHashing) /* enquanto houver distritos */
    {
        NODO *nodoReq = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante do distrito */

        while(nodoReq) /* enquanto houver requisitantes naquele distrito */
        {
            REQUISITANTE *reqInfo = (REQUISITANTE *)nodoReq->info;

            if(strcasecmp(reqInfo->nome, nome) == 0)
                return reqInfo;

            nodoReq = nodoReq->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return NULL;
}

/** ---------- VERIFICAR SE EXISTE UM REQUISITANTE DE UM DADO DISTRITO, COM UM CERTO NOME ---------- */

int existeReqDistNome(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.\n");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("\nO hashing de distritos está vazio (0 requisitantes).\n");
        return 0;
    }

    int choice = 0;
    char nomeEncontrar[60];
    char temp;
    int contador = 0;

    do
    {
        /* Devemos primeiro mostrar todos os distritos disponiveis, com os números correspondentes */

        printf("\n- Insira o número correspondente ao distrito: ");
        scanf("%d", &choice);

    }while(choice < 1 || choice > 18);

    NODO_HASHING *aux = hashingDist->inicio;

    while(aux)
    {
        int numDist =atoi(aux->numero); /* Converter em INT para poder comparar */

        if(numDist == choice)
        {
            if(!aux->lista)
            {
                printf("\nA lista de requisitantes do distrito [%s] não existe.\n");
                return 0;
            }

            if(!aux->lista->inicio)
            {
                printf("\nA lista de requisitantes do distrito [%s] está vazia (0 requisitantes).\n");
                return 0;
            }

            NODO *auxNodo = aux->lista->inicio;

            printf("\n- Insira o nome que deseja procurar: ");
            scanf("%c",&temp);
            scanf("%[^\n]", nomeEncontrar);

            /* Devemos percorrer a lista correspondente ao distrito encontrado, à procura dos requisitantes que têm no nome, aquele nome inserido */

            while(auxNodo)
            {
                REQUISITANTE *reqInfo = auxNodo->info; /* Recuperamos a informação do requisitante */

                char *found = strstr(reqInfo->nome, nomeEncontrar);

                if(found != NULL) /* Neste caso, foi encontrado a substring do nome, dentro de um requisitante */
                    contador++;

                auxNodo = auxNodo->seg;
            }
            return contador;
        }
        else
            aux = aux->seg;
    }
    return contador;
}

/** ---------- DETERMINA O NUMERO DE DIAS DE FEVEREIRO DE UM DETERMINADO ANO ---------- */

void corrige_meses(int year, int daysOfMonth[]){

    if(bissexto(year))
         daysOfMonth[2] = 29;

    else
        daysOfMonth[2] = 28;
}
/** ---------- MOSTRAR OS DADOS DE UM REQUISITANTE ---------- */

void mostrarReq(REQUISITANTE *req)
{
    if(!req)
    {
        printf("O requisitante não existe.");
        return;
    }

    printf("\n\n--------------------------------------------------");
    printf("\n          Requisitante Nº %s", req->id);
    printf("\n--------------------------------------------------");

    printf("\n\n- Nome: %s", req->nome);

    printf("\n\n- Data de nascimento: %02d/%02d/%04d", req->diaNasc, req->mesNasc, req->anoNasc);

    printf("\n\n- ID freguesia: %s", req->idFreguesia);
}

/** ---------- MOSTRAR A LISTA DE REQUISITANTES ---------- */

void mostrarListaReq(LISTA *lista)
{
    NODO *nodo = lista->inicio;
    int cont = 0;

    while(nodo)
    {
        REQUISITANTE *dados = nodo->info;
        mostrarReq(dados);
        nodo = nodo->seg;
        cont++;
    }
}

/** ---------- DEVOLVER O NUMERO DE REQUISITANTES NA LISTA ---------- */

int contaReq(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.");
        return;
    }

    NODO_HASHING *nodoHashing = hashingDist->inicio;
    int contador = 0;

    while(nodoHashing)
    {
        NODO *nodo = nodoHashing->lista->inicio;

        while(nodo)
        {
            contador++;
            nodo = nodo->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return contador;
}

/** ---------- CONCATENAR DOIS INTEGERS ---------- */

int concatInteger(int a, int b)
{

    char s1[20];
    char s2[20];

    // Convert both the integers to string
    sprintf(s1, "%02d", a);
    sprintf(s2, "%02d", b);

    // Concatenate both strings
    strcat(s1, s2);

    // Convert the concatenated string
    // to integer
    int c = atoi(s1);

    // return the formed integer
    return c;
}

/** ---------- CALCULAR A IDADE DE UM DADO REQUISITANTE ---------- */

int calcularIdade(REQUISITANTE *req)
{
    time_t tempo = time(NULL);
    struct tm tm = *localtime(&tempo);

    int ano = tm.tm_year + 1900;
    int mes = tm.tm_mon + 1;
    int dia = tm.tm_mday;
    int idade;

    if(!req)
    {
        printf("O requisitante não existe.");
        return;
    }


    if(mes < req->mesNasc) /* Neste caso, o requisitante ainda não fez anos */
    {
        idade = ano - req->anoNasc - 1;
        return idade;
    }

    else /* Neste caso, o requisitante nasceu antes do mês atual, ou neste mês */
    {
        if(mes == req->mesNasc) /* O requisitante vai fazer anos este mês, devemos conhecer o dia */
        {
            if(dia < req->diaNasc) /* Neste caso, o requisitante nasceu depois do dia de hoje (ainda não fez anos)  */
            {
                idade = ano - req->anoNasc - 1;
                return idade;
            }
        }
        idade = ano - req->anoNasc; /* O requisitante nasceu antes do mês atual */
        return idade;
    }
}

/** ---------- DETERMINAR A IDADE MAXIMA DE TODOS OS REQUISITANTES ---------- */

REQUISITANTE *idadeMax(HASHING *hashingDist)
{
    int max = 0;

    if(!hashingDist)
    {
        printf("O hashing de distritos não existe.");
        return NULL;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return NULL;
    }

    NODO_HASHING *nodoHashing = hashingDist->inicio;
    REQUISITANTE *req;

    while(nodoHashing) /* Enquanto existir distritos */
    {
        NODO *aux = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante daquele distrito */

        while(aux) /* Enquanto existir requisitantes naquele distrito */
        {
            int idade = calcularIdade((REQUISITANTE *)aux->info);

            if (idade > max)
            {
                max = idade;
                req = (REQUISITANTE *)aux->info;
            }
            aux = aux->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return req;
}

/** ---------- DETERMINAR A IDADE MEDIA DE TODOS OS REQUISITANTES ---------- */

int idadeMedia(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("O hashing de distritos não existe.");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return 0;
    }

    NODO_HASHING *nodoHahing = hashingDist->inicio;
    int totalReq = 0, media = 0;
    float soma = 0.0;

    while(nodoHahing) /* Enquanto houver distritos */
    {
        NODO *aux = nodoHahing->lista->inicio; /* Bscar o primeiro requisitante da cidade */

        while(aux) /* Enquanto houver requisitantes naquele distrito */
        {
            int idadeReq = calcularIdade((REQUISITANTE *)aux->info);
            soma += idadeReq;
            totalReq++;
            aux = aux->seg; /* Requisitante seguinte */
        }
        nodoHahing = nodoHahing->seg;  /**Distrito seguinte */
    }
    media = soma / totalReq;
    return media;
}

/** ---------- DETERMINAR O NUMERO DE REQUISITANTES, QUE TÊM A IDADE > A IDADE INSERIDA PELO UTILIZADOR ---------- */

int idadeSup(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("O hashing de distritos não existe.");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return 0;
    }

    int totalReq = 0;
    int idadeLimitadora;

    do
    {
        printf("\nInsira a idade limite (exclusive): ");
        scanf("%d", &idadeLimitadora);

    }while(idadeLimitadora <= 0 || idadeLimitadora > 100);

    NODO_HASHING *nodoHashing = hashingDist->inicio;

    while(nodoHashing) /* Enquanto houver distritos */
    {
        NODO *auxReq = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante do distrito */

        while(auxReq) /* Enquanto houver requisitantes naquele distrito */
        {
            int idade = calcularIdade((REQUISITANTE *)auxReq->info);

            if (idade > idadeLimitadora)
                    totalReq++;

            auxReq = auxReq->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return totalReq;
}

/** ---------- VALIDAR O ID DE CADA REQUISITANTE ---------- */

int validarIdReq(char id[10]) /* 0: inválido / 1: válido */
{
    if(!id)
    {
        printf("\nO ID não existe.\n");
        return 0;
    }

    /* Verificar se o ID contem 9 algarismos */

    int tamanho = (int)strlen(id);

    if(tamanho != 9)
        return 0;

    /* Verificar se a soma dos 9 algarismos é um multiplo de 10 */

    int i;
    int soma = 0;

    for(i = 0; i < tamanho; i++)
        soma += (int)id[i]-'0'; /* Transformar um char em int (com o devido código ASCII) */

    if(soma % 10 == 0) /* Se o resto da soma for igual a 0, indicará a validade do ID */
        return 1;

    return 0;
}

/** ---------- VERIFICAR SE O ANO É BISSEXTO ---------- */

int bissexto(int ano)
{
    if (ano % 4 == 0)
    {
        if (ano % 100 == 0)
            return 0;
        return 1;
    }

    else
    {
        if (ano % 400 == 0)
                return 1;
        return 0;
    }
}

/** ---------- VALIDAR A DATA DE NASCIMENTO DE CADA REQUISITANTE ---------- */

int validarDataNasc(char dataNasc[40])
{
    if(!dataNasc)
    {
        printf("\nOcorreu um erro na leitura da data de nascimento.\n");
        return 0;
    }

    /* Validar o formato da data */

    int dia, mes, ano;

    int validadeFormato = sscanf(dataNasc, "%d-%d-%d", &dia, &mes, &ano);

    if(validadeFormato != 3)
        return 0;

    /* Validar o ano */

    time_t currTime = time(NULL);
    struct tm tm = *localtime(&currTime);

    int anoAtual = tm.tm_year + 1900;

    if(ano < 1900 || ano >= anoAtual)
        return 0;

    int anoBissexto = bissexto(ano); /* ESTA FUNÇÃO NÃO ESTÁ A FUNCIONAR CORRETAMENTE */

    /* Validar o mês */

    if(mes < 1 || mes > 12)
        return 0;

    /* Validar o dia, consoante o mês */

    switch(mes)
    {
        case 1:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 2:
        {
            if(anoBissexto) /* Ano bissexto */
            {
                if(dia < 1 || dia > 29)
                    return 0;
                return 1;
            }

            else /* Ano não bissexto */
            {
                if(dia < 1 || dia > 28)
                    return 0;
                return 1;
            }
            break;
        }

        case 3:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 4:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 5:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 6:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 7:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 8:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 9:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 10:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 11:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 12:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }
    }
}

/** ---------- VALIDAR O ID DA FREGUESIA DO REQUISITANTE  ---------- */

int validarIDFreg(char idFreg[7], char *nomeFic)
{
    if(!idFreg)
    {
        printf("\nOcorreu um erro na leitura do ID de freguesia.\n");
        return;
    }

    int tamanho = strlen(idFreg);

    if(tamanho != 6)
        return 0;

    FILE *fic;
    char linha[120];
    fic = fopen(nomeFic, "r");

    if(!fic)
    {
        printf("\nNão foi possível abrir o ficheiro [%s].\n", nomeFic);
        fclose(fic);
        return 0;
    }

    while(!feof(fic))
    {
        if(fgets(linha, 120, fic) != NULL) /* Verifica se  leitura foi feita com sucesso */
        {
            char *found = strstr(linha, idFreg);
            if(found != NULL)
            {
                fclose(fic);
                return 1;
            }
        }
    }
    fclose(fic);
    return 0;
}



/** ---------- VERIFICAR SE UM REQUISITANTE EXISTE, INSERINDO O NOME DELE (COMPLETO) ---------- */
/** Inseriro nome completo, é a única maneira de saber se AQUELE requisitante existe. Pois podem exisitir varios João, Maria...*/

REQUISITANTE *existeReq(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.\n");
        return NULL;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return NULL;
    }

    char nome[60];
    char temp;

    printf("\n- Nome do requisitante: ");
    scanf("%c",&temp);
    scanf("%[^\n]", nome);

    NODO_HASHING *nodoHashing = hashingDist->inicio;

    while(nodoHashing) /* enquanto houver distritos */
    {
        NODO *nodoReq = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante do distrito */

        while(nodoReq) /* enquanto houver requisitantes naquele distrito */
        {
            REQUISITANTE *reqInfo = (REQUISITANTE *)nodoReq->info;

            if(strcasecmp(reqInfo->nome, nome) == 0)
                return reqInfo;

            nodoReq = nodoReq->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return NULL;
}

/** ---------- VERIFICAR SE EXISTE UM REQUISITANTE DE UM DADO DISTRITO, COM UM CERTO NOME ---------- */

int existeReqDistNome(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.\n");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("\nO hashing de distritos está vazio (0 requisitantes).\n");
        return 0;
    }

    int choice = 0;
    char nomeEncontrar[60];
    char temp;
    int contador = 0;

    do
    {
        /* Devemos primeiro mostrar todos os distritos disponiveis, com os números correspondentes */

        printf("\n- Insira o número correspondente ao distrito: ");
        scanf("%d", &choice);

    }while(choice < 1 || choice > 18);

    NODO_HASHING *aux = hashingDist->inicio;

    while(aux)
    {
        int numDist =atoi(aux->numero); /* Converter em INT para poder comparar */

        if(numDist == choice)
        {
            if(!aux->lista)
            {
                printf("\nA lista de requisitantes do distrito [%s] não existe.\n");
                return 0;
            }

            if(!aux->lista->inicio)
            {
                printf("\nA lista de requisitantes do distrito [%s] está vazia (0 requisitantes).\n");
                return 0;
            }

            NODO *auxNodo = aux->lista->inicio;

            printf("\n- Insira o nome que deseja procurar: ");
            scanf("%c",&temp);
            scanf("%[^\n]", nomeEncontrar);

            /* Devemos percorrer a lista correspondente ao distrito encontrado, à procura dos requisitantes que têm no nome, aquele nome inserido */

            while(auxNodo)
            {
                REQUISITANTE *reqInfo = auxNodo->info; /* Recuperamos a informação do requisitante */

                char *found = strstr(reqInfo->nome, nomeEncontrar);

                if(found != NULL) /* Neste caso, foi encontrado a substring do nome, dentro de um requisitante */
                    contador++;

                auxNodo = auxNodo->seg;
            }
            return contador;
        }
        else
            aux = aux->seg;
    }
    return contador;
}

/** ---------- DETERMINA O NUMERO DE DIAS DE FEVEREIRO DE UM DETERMINADO ANO ---------- */

void corrige_meses(int year, int daysOfMonth[]){

    if(bissexto(year))
         daysOfMonth[2] = 29;

    else
        daysOfMonth[2] = 28;
}


/** ---------- MOSTRAR OS DADOS DE UM REQUISITANTE ---------- */

void mostrarReq(REQUISITANTE *req)
{
    if(!req)
    {
        printf("O requisitante não existe.");
        return;
    }

    printf("\n\n--------------------------------------------------");
    printf("\n          Requisitante Nº %s", req->id);
    printf("\n--------------------------------------------------");

    printf("\n\n- Nome: %s", req->nome);

    printf("\n\n- Data de nascimento: %02d/%02d/%04d", req->diaNasc, req->mesNasc, req->anoNasc);

    printf("\n\n- ID freguesia: %s", req->idFreguesia);
}

/** ---------- MOSTRAR A LISTA DE REQUISITANTES ---------- */

void mostrarListaReq(LISTA *lista)
{
    NODO *nodo = lista->inicio;
    int cont = 0;

    while(nodo)
    {
        REQUISITANTE *dados = nodo->info;
        mostrarReq(dados);
        nodo = nodo->seg;
        cont++;
    }
}

/** ---------- DEVOLVER O NUMERO DE REQUISITANTES NA LISTA ---------- */

int contaReq(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.");
        return;
    }

    NODO_HASHING *nodoHashing = hashingDist->inicio;
    int contador = 0;

    while(nodoHashing)
    {
        NODO *nodo = nodoHashing->lista->inicio;

        while(nodo)
        {
            contador++;
            nodo = nodo->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return contador;
}


/** ---------- CONCATENAR DOIS INTEGERS ---------- */

int concatInteger(int a, int b)
{

    char s1[20];
    char s2[20];

    // Convert both the integers to string
    sprintf(s1, "%02d", a);
    sprintf(s2, "%02d", b);

    // Concatenate both strings
    strcat(s1, s2);

    // Convert the concatenated string
    // to integer
    int c = atoi(s1);

    // return the formed integer
    return c;
}

/** ---------- CALCULAR A IDADE DE UM DADO REQUISITANTE ---------- */

int calcularIdade(REQUISITANTE *req)
{
    time_t tempo = time(NULL);
    struct tm tm = *localtime(&tempo);

    int ano = tm.tm_year + 1900;
    int mes = tm.tm_mon + 1;
    int dia = tm.tm_mday;
    int idade;

    if(!req)
    {
        printf("O requisitante não existe.");
        return;
    }


    if(mes < req->mesNasc) /* Neste caso, o requisitante ainda não fez anos */
    {
        idade = ano - req->anoNasc - 1;
        return idade;
    }

    else /* Neste caso, o requisitante nasceu antes do mês atual, ou neste mês */
    {
        if(mes == req->mesNasc) /* O requisitante vai fazer anos este mês, devemos conhecer o dia */
        {
            if(dia < req->diaNasc) /* Neste caso, o requisitante nasceu depois do dia de hoje (ainda não fez anos)  */
            {
                idade = ano - req->anoNasc - 1;
                return idade;
            }
        }
        idade = ano - req->anoNasc; /* O requisitante nasceu antes do mês atual */
        return idade;
    }
}

/** ---------- DETERMINAR A IDADE MAXIMA DE TODOS OS REQUISITANTES ---------- */

REQUISITANTE *idadeMax(HASHING *hashingDist)
{
    int max = 0;

    if(!hashingDist)
    {
        printf("O hashing de distritos não existe.");
        return NULL;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return NULL;
    }

    NODO_HASHING *nodoHashing = hashingDist->inicio;
    REQUISITANTE *req;

    while(nodoHashing) /* Enquanto existir distritos */
    {
        NODO *aux = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante daquele distrito */

        while(aux) /* Enquanto existir requisitantes naquele distrito */
        {
            int idade = calcularIdade((REQUISITANTE *)aux->info);

            if (idade > max)
            {
                max = idade;
                req = (REQUISITANTE *)aux->info;
            }
            aux = aux->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return req;
}

/** ---------- DETERMINAR A IDADE MEDIA DE TODOS OS REQUISITANTES ---------- */

int idadeMedia(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("O hashing de distritos não existe.");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return 0;
    }

    NODO_HASHING *nodoHahing = hashingDist->inicio;
    int totalReq = 0, media = 0;
    float soma = 0.0;

    while(nodoHahing) /* Enquanto houver distritos */
    {
        NODO *aux = nodoHahing->lista->inicio; /* Bscar o primeiro requisitante da cidade */

        while(aux) /* Enquanto houver requisitantes naquele distrito */
        {
            int idadeReq = calcularIdade((REQUISITANTE *)aux->info);
            soma += idadeReq;
            totalReq++;
            aux = aux->seg; /* Requisitante seguinte */
        }
        nodoHahing = nodoHahing->seg;  /**Distrito seguinte */
    }
    media = soma / totalReq;
    return media;
}

/** ---------- DETERMINAR O NUMERO DE REQUISITANTES, QUE TÊM A IDADE > A IDADE INSERIDA PELO UTILIZADOR ---------- */

int idadeSup(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("O hashing de distritos não existe.");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return 0;
    }

    int totalReq = 0;
    int idadeLimitadora;

    do
    {
        printf("\nInsira a idade limite (exclusive): ");
        scanf("%d", &idadeLimitadora);

    }while(idadeLimitadora <= 0 || idadeLimitadora > 100);

    NODO_HASHING *nodoHashing = hashingDist->inicio;

    while(nodoHashing) /* Enquanto houver distritos */
    {
        NODO *auxReq = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante do distrito */

        while(auxReq) /* Enquanto houver requisitantes naquele distrito */
        {
            int idade = calcularIdade((REQUISITANTE *)auxReq->info);

            if (idade > idadeLimitadora)
                    totalReq++;

            auxReq = auxReq->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return totalReq;
}

/** ---------- VALIDAR O ID DE CADA REQUISITANTE ---------- */

int validarIdReq(char id[10]) /* 0: inválido / 1: válido */
{
    if(!id)
    {
        printf("\nO ID não existe.\n");
        return 0;
    }

    /* Verificar se o ID contem 9 algarismos */

    int tamanho = (int)strlen(id);

    if(tamanho != 9)
        return 0;

    /* Verificar se a soma dos 9 algarismos é um multiplo de 10 */

    int i;
    int soma = 0;

    for(i = 0; i < tamanho; i++)
        soma += (int)id[i]-'0'; /* Transformar um char em int (com o devido código ASCII) */

    if(soma % 10 == 0) /* Se o resto da soma for igual a 0, indicará a validade do ID */
        return 1;

    return 0;
}

/** ---------- VERIFICAR SE O ANO É BISSEXTO ---------- */

int bissexto(int ano)
{
    if (ano % 4 == 0)
    {
        if (ano % 100 == 0)
            return 0;
        return 1;
    }

    else
    {
        if (ano % 400 == 0)
                return 1;
        return 0;
    }
}

/** ---------- VALIDAR A DATA DE NASCIMENTO DE CADA REQUISITANTE ---------- */

int validarDataNasc(char dataNasc[40])
{
    if(!dataNasc)
    {
        printf("\nOcorreu um erro na leitura da data de nascimento.\n");
        return 0;
    }

    /* Validar o formato da data */

    int dia, mes, ano;

    int validadeFormato = sscanf(dataNasc, "%d-%d-%d", &dia, &mes, &ano);

    if(validadeFormato != 3)
        return 0;

    /* Validar o ano */

    time_t currTime = time(NULL);
    struct tm tm = *localtime(&currTime);

    int anoAtual = tm.tm_year + 1900;

    if(ano < 1900 || ano >= anoAtual)
        return 0;

    int anoBissexto = bissexto(ano); /* ESTA FUNÇÃO NÃO ESTÁ A FUNCIONAR CORRETAMENTE */

    /* Validar o mês */

    if(mes < 1 || mes > 12)
        return 0;

    /* Validar o dia, consoante o mês */

    switch(mes)
    {
        case 1:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 2:
        {
            if(anoBissexto) /* Ano bissexto */
            {
                if(dia < 1 || dia > 29)
                    return 0;
                return 1;
            }

            else /* Ano não bissexto */
            {
                if(dia < 1 || dia > 28)
                    return 0;
                return 1;
            }
            break;
        }

        case 3:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 4:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 5:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 6:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 7:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 8:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 9:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 10:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 11:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 12:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }
    }
}

/** ---------- VALIDAR O ID DA FREGUESIA DO REQUISITANTE  ---------- */

int validarIDFreg(char idFreg[7], char *nomeFic)
{
    if(!idFreg)
    {
        printf("\nOcorreu um erro na leitura do ID de freguesia.\n");
        return;
    }

    int tamanho = strlen(idFreg);

    if(tamanho != 6)
        return 0;

    FILE *fic;
    char linha[120];
    fic = fopen(nomeFic, "r");

    if(!fic)
    {
        printf("\nNão foi possível abrir o ficheiro [%s].\n", nomeFic);
        fclose(fic);
        return 0;
    }

    while(!feof(fic))
    {
        if(fgets(linha, 120, fic) != NULL) /* Verifica se  leitura foi feita com sucesso */
        {
            char *found = strstr(linha, idFreg);
            if(found != NULL)
            {
                fclose(fic);
                return 1;
            }
        }
    }
    fclose(fic);
    return 0;
}


/** ---------- VERIFICAR SE UM REQUISITANTE EXISTE, INSERINDO O NOME DELE (COMPLETO) ---------- */
/** Inseriro nome completo, é a única maneira de saber se AQUELE requisitante existe. Pois podem exisitir varios João, Maria...*/

REQUISITANTE *existeReq(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.\n");
        return NULL;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return NULL;
    }

    char nome[60];
    char temp;

    printf("\n- Nome do requisitante: ");
    scanf("%c",&temp);
    scanf("%[^\n]", nome);

    NODO_HASHING *nodoHashing = hashingDist->inicio;

    while(nodoHashing) /* enquanto houver distritos */
    {
        NODO *nodoReq = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante do distrito */

        while(nodoReq) /* enquanto houver requisitantes naquele distrito */
        {
            REQUISITANTE *reqInfo = (REQUISITANTE *)nodoReq->info;

            if(strcasecmp(reqInfo->nome, nome) == 0)
                return reqInfo;

            nodoReq = nodoReq->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return NULL;
}

/** ---------- VERIFICAR SE EXISTE UM REQUISITANTE DE UM DADO DISTRITO, COM UM CERTO NOME ---------- */

int existeReqDistNome(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.\n");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("\nO hashing de distritos está vazio (0 requisitantes).\n");
        return 0;
    }

    int choice = 0;
    char nomeEncontrar[60];
    char temp;
    int contador = 0;

    do
    {
        /* Devemos primeiro mostrar todos os distritos disponiveis, com os números correspondentes */

        printf("\n- Insira o número correspondente ao distrito: ");
        scanf("%d", &choice);

    }while(choice < 1 || choice > 18);

    NODO_HASHING *aux = hashingDist->inicio;

    while(aux)
    {
        int numDist =atoi(aux->numero); /* Converter em INT para poder comparar */

        if(numDist == choice)
        {
            if(!aux->lista)
            {
                printf("\nA lista de requisitantes do distrito [%s] não existe.\n");
                return 0;
            }

            if(!aux->lista->inicio)
            {
                printf("\nA lista de requisitantes do distrito [%s] está vazia (0 requisitantes).\n");
                return 0;
            }

            NODO *auxNodo = aux->lista->inicio;

            printf("\n- Insira o nome que deseja procurar: ");
            scanf("%c",&temp);
            scanf("%[^\n]", nomeEncontrar);

            /* Devemos percorrer a lista correspondente ao distrito encontrado, à procura dos requisitantes que têm no nome, aquele nome inserido */

            while(auxNodo)
            {
                REQUISITANTE *reqInfo = auxNodo->info; /* Recuperamos a informação do requisitante */

                char *found = strstr(reqInfo->nome, nomeEncontrar);

                if(found != NULL) /* Neste caso, foi encontrado a substring do nome, dentro de um requisitante */
                    contador++;

                auxNodo = auxNodo->seg;
            }
            return contador;
        }
        else
            aux = aux->seg;
    }
    return contador;
}

/** ---------- DETERMINA O NUMERO DE DIAS DE FEVEREIRO DE UM DETERMINADO ANO ---------- */

void corrige_meses(int year, int daysOfMonth[]){

    if(bissexto(year))
         daysOfMonth[2] = 29;

    else
        daysOfMonth[2] = 28;
}

    /* Validar o formato da data */

    int dia, mes, ano;

    int validadeFormato = sscanf(dataNasc, "%d-%d-%d", &dia, &mes, &ano);

    if(validadeFormato != 3)
        return 0;

    /* Validar o ano */

    time_t currTime = time(NULL);
    struct tm tm = *localtime(&currTime);

    int anoAtual = tm.tm_year + 1900;

    if(ano < 1900 || ano >= anoAtual)
        return 0;

    int anoBissexto = bissexto(ano); /* ESTA FUNÇÃO NÃO ESTÁ A FUNCIONAR CORRETAMENTE */

    /* Validar o mês */

    if(mes < 1 || mes > 12)
        return 0;

    /* Validar o dia, consoante o mês */

    switch(mes)
    {
        case 1:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 2:
        {
            if(anoBissexto) /* Ano bissexto */
            {
                if(dia < 1 || dia > 29)
                    return 0;
                return 1;
            }

            else /* Ano não bissexto */
            {
                if(dia < 1 || dia > 28)
                    return 0;
                return 1;
            }
            break;
        }

        case 3:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 4:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 5:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 6:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 7:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 8:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 9:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 10:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }

        case 11:
        {
            if(dia < 1 || dia > 30)
                return 0;
            return 1;
            break;
        }

        case 12:
        {
            if(dia < 1 || dia > 31)
                return 0;
            return 1;
            break;
        }
    }
}

/** ---------- VALIDAR O ID DA FREGUESIA DO REQUISITANTE  ---------- */

int validarIDFreg(char idFreg[7], char *nomeFic)
{
    if(!idFreg)
    {
        printf("\nOcorreu um erro na leitura do ID de freguesia.\n");
        return;
    }

    int tamanho = strlen(idFreg);

    if(tamanho != 6)
        return 0;

    FILE *fic;
    char linha[120];
    fic = fopen(nomeFic, "r");

    if(!fic)
    {
        printf("\nNão foi possível abrir o ficheiro [%s].\n", nomeFic);
        fclose(fic);
        return 0;
    }

    while(!feof(fic))
    {
        if(fgets(linha, 120, fic) != NULL) /* Verifica se  leitura foi feita com sucesso */
        {
            char *found = strstr(linha, idFreg);
            if(found != NULL)
            {
                fclose(fic);
                return 1;
            }
        }
    }
    fclose(fic);
    return 0;
}



/** ---------- VERIFICAR SE UM REQUISITANTE EXISTE, INSERINDO O NOME DELE (COMPLETO) ---------- */
/** Inseriro nome completo, é a única maneira de saber se AQUELE requisitante existe. Pois podem exisitir varios João, Maria...*/

REQUISITANTE *existeReq(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.\n");
        return NULL;
    }

    if(!hashingDist->inicio)
    {
        printf("O hashing de distritos está vazio (0 requisitantes).");
        return NULL;
    }

    char nome[60];
    char temp;

    printf("\n- Nome do requisitante: ");
    scanf("%c",&temp);
    scanf("%[^\n]", nome);

    NODO_HASHING *nodoHashing = hashingDist->inicio;

    while(nodoHashing) /* enquanto houver distritos */
    {
        NODO *nodoReq = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante do distrito */

        while(nodoReq) /* enquanto houver requisitantes naquele distrito */
        {
            REQUISITANTE *reqInfo = (REQUISITANTE *)nodoReq->info;

            if(strcasecmp(reqInfo->nome, nome) == 0)
                return reqInfo;

            nodoReq = nodoReq->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    return NULL;
}

/** ---------- VERIFICAR SE EXISTE UM REQUISITANTE DE UM DADO DISTRITO, COM UM CERTO NOME ---------- */

int existeReqDistNome(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\nO hashing de distritos não existe.\n");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("\nO hashing de distritos está vazio (0 requisitantes).\n");
        return 0;
    }

    int choice = 0;
    char nomeEncontrar[60];
    char temp;
    int contador = 0;

    do
    {
        /* Devemos primeiro mostrar todos os distritos disponiveis, com os números correspondentes */

        printf("\n- Insira o número correspondente ao distrito: ");
        scanf("%d", &choice);

    }while(choice < 1 || choice > 18);

    NODO_HASHING *aux = hashingDist->inicio;

    while(aux)
    {
        int numDist =atoi(aux->numero); /* Converter em INT para poder comparar */

        if(numDist == choice)
        {
            if(!aux->lista)
            {
                printf("\nA lista de requisitantes do distrito [%s] não existe.\n");
                return 0;
            }

            if(!aux->lista->inicio)
            {
                printf("\nA lista de requisitantes do distrito [%s] está vazia (0 requisitantes).\n");
                return 0;
            }

            NODO *auxNodo = aux->lista->inicio;

            printf("\n- Insira o nome que deseja procurar: ");
            scanf("%c",&temp);
            scanf("%[^\n]", nomeEncontrar);

            /* Devemos percorrer a lista correspondente ao distrito encontrado, à procura dos requisitantes que têm no nome, aquele nome inserido */

            while(auxNodo)
            {
                REQUISITANTE *reqInfo = auxNodo->info; /* Recuperamos a informação do requisitante */

                char *found = strstr(reqInfo->nome, nomeEncontrar);

                if(found != NULL) /* Neste caso, foi encontrado a substring do nome, dentro de um requisitante */
                    contador++;

                auxNodo = auxNodo->seg;
            }
            return contador;
        }
        else
            aux = aux->seg;
    }
    return contador;
}

/** ---------- DETERMINA O NUMERO DE DIAS DE FEVEREIRO DE UM DETERMINADO ANO ---------- */

void corrige_meses(int year, int daysOfMonth[]){

    if(bissexto(year))
         daysOfMonth[2] = 29;

    else
        daysOfMonth[2] = 28;
}

/** ---------- LISTAR REQUISITANTES CUJO ANIVERSÁRIO, NUM DETERMINADO ANO, É NA QUARESMA(ENTRE O CARNAVAL E A PÁSCOA),(OU QUE NASCERAM NA QUARESMA) ---------- Exercicio 4n */

void aniversarioRequisitanteQuaresma(int ano, HASHING *hashingDist, int variavelFuncao) /** Se a variavelFuncao for 1, entao determina do aniversário, se for 2 determina do ano de nascimento */
{
/** ---------- Receber o ano e saber o periodo da quaresma ---------- */

    /** Fórmula para calculo da páscoa */
    /**
    a = MOD(ANO;19)
    b = ANO \ 100
    c = MOD(ANO;100)
    d = b \ 4
    e = MOD(b;4)
    f = (b + 8) \ 25
    g = (b - f + 1) \ 3
    h = MOD((19 × a + b - d - g + 15);30)
    i = c \ 4
    k = MOD(c;4)
    L = MOD((32 + 2 × e + 2 × i - h - k);7)
    m = (a + 11 × h + 22 × L) \ 451
    MÊS = (h + L - 7 × m + 114) \ 31
    DIA = MOD((h + L - 7 × m + 114);31) + 1
    */

    int a,b,c,d,e,f,g,h,i,k,l,m,diaPascoa,mesPascoa,diaQuartaCinzas,mesQuartaCinzas,diaCerto,mesCerto,anoCerto,mesIntermedio;

    a = ano%19;
    b = ano/100;
    c = ano%100;
    d = b/4;
    e = b%4;
    f = (b+8) / 25;
    g = (b-f+1) / 3;
    h = (19 * a + b - d - g + 15)%30;
    i = c / 4;
    k = c%4;
    l = (32 + 2 * e + 2 * i - h - k)%7;
    m = (a + 11 * h + 22 * l) /451;
    mesPascoa = (h + l - 7 * m + 114) / 31;
    diaPascoa = ((h + l - 7 * m + 114)%31) + 1;

    printf("\n A páscoa em 2019 é no dia %d e o mês é no dia %d",diaPascoa,mesPascoa);

    diaQuartaCinzas = diaPascoa;
    mesQuartaCinzas = mesPascoa;

        /** esta lista é a lista de dias que cada mês tem */
        static int days_in_month[] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

        /** Esta função irá corrigir o mês de fevereiro deste ano caso o ano seja bissexto */
        corrige_meses(ano,days_in_month);

        /** Função que descobre a data da quarta feira de cinzas, irá percorrer os 40 dias que antecedes à páscoa descoberta anteriormente */
            for(int o = 1; o <= 46; o++)
            {

                /** Decrementa 1 dia e irá ver se o dia for inferior a 1, caso seja o caso vai decrementar também o mês, mas precisa de se saber se foi para fevereiro */
                diaQuartaCinzas -= 1 ;
                if(diaQuartaCinzas < 1)
                {
                    mesQuartaCinzas -= 1;
                    diaQuartaCinzas = days_in_month[mesQuartaCinzas];
                }
            }

        printf("\n o dia da quaresma %d e o mes é %d.",diaQuartaCinzas,mesQuartaCinzas);




    /** ---------- Percorrer a lista de requisitantes e comparar a data de nascimento com a o periodo de quaresma ---------- */


    NODO_HASHING *nodoHahing = hashingDist->inicio; /** Buscar a primeira cidade da lista */
  //  int totalReq = 0, media = 0;
  //  float soma = 0.0;

    if(variavelFuncao == 1)
        {
            printf("\n-------------- Lista de requisitantes que no ano %d cujo aniversário é na quaresma --------------",ano);
        }

    if(variavelFuncao == 2)
        {
            printf("\n-------------- Lista de requisitantes que no ano %d nasceram na quaresma --------------",ano);
        }



    mesIntermedio == NULL;

    /** Vai calcular a diferença ente o mes da pascoa e o mes de quarta feira de cinzas */
    if(mesPascoa-mesQuartaCinzas == 2)
    {
        /** Se houver vai atribuir esse mes intermedio à variavel */
        mesIntermedio = mesPascoa-1;
    }



    while(nodoHahing) /** Enquanto houver distritos */
    {
        NODO *aux = nodoHahing->lista->inicio; /** Buscar o primeiro requisitante da cidade */

        while(aux) /** Enquanto houver requisitantes naquele distrito */
        {
            REQUISITANTE *informacoes = aux->info;

            if(variavelFuncao == 1) /**  requisitante que o aniversário é na quaresma */
            {
                if(informacoes->anoNasc >= ano)
                {
                    if(informacoes->mesNasc <= mesPascoa && informacoes->mesNasc >= mesQuartaCinzas)
                    {
                            if((informacoes->mesNasc == mesQuartaCinzas  &&  informacoes->diaNasc >= diaQuartaCinzas  &&  informacoes->diaNasc <= days_in_month[mesQuartaCinzas]) || (informacoes->diaNasc <= diaPascoa  &&  informacoes->mesNasc == mesPascoa) || (mesIntermedio != NULL  &&  informacoes->mesNasc == mesIntermedio  ) ) /** Se nasceram no mês da quarta feira de cinzas,se nasceram no mês da páscoa, se nasceram no mês da páscoa, ou se nasceram, caso haja, um mês completo ente a Quarta de cinzas e a páscoa que não sejam desses mesmos */
                                printf("\n\t%s dia:%d mês:%d ",informacoes->nome,informacoes->anoNasc,informacoes->mesNasc);
                    }
                }
            }

            if(variavelFuncao == 2) /**  requisitante que nasceu na quaresma */
            {
                if(informacoes->anoNasc == ano)
                {
                    if((informacoes->mesNasc == mesQuartaCinzas && informacoes->diaNasc >= diaQuartaCinzas && informacoes->diaNasc <= days_in_month[mesQuartaCinzas]) || (informacoes->diaNasc <= diaPascoa && informacoes->mesNasc == mesPascoa) || (mesIntermedio != NULL  &&  informacoes->mesNasc == mesIntermedio  ) ) /** Se nasceram no mês da quarta feira de cinzas,se nasceram no mês da páscoa, ou se nasceram, caso haja, um mês completo ente a Quarta de cinzas e a páscoa que não sejam desses mesmos */
                         printf("\n\t%s dia:%d mês:%d ",informacoes->nome,informacoes->anoNasc,informacoes->mesNasc);
                }

            }
            aux = aux->seg; /** Requisitante seguinte */
        }
        nodoHahing = nodoHahing->seg;  /**Distrito seguinte */
    }
}


/** ---------- FUNÇÃO QUE DEVOLVE SE A DATA RECEBIDA É DOMINGO OU NÃO ---------- */

    int devolverDomingo(int d, int m, int y)
    {

        if( (d > 31) || (m > 12))
         {
            printf("Insira um mês ou dia correto");
            exit(0);
         }

        int year, month, day, i;

        year = y-1900;
        year = year/4;
        year = year+y-1900;

         switch(m)
         {
             case 1:
             case 10:
             month = 1;
            break;

             case 2:
             case 3:
             case 11:
             month = 4;
             break;

             case 7:
             case 4:
             month = 0;
             break;

             case 5:
             month = 2;
             break;

             case 6:
             month = 5;
             break;

             case 8:
             month = 3;
             break;

             case 9:
             case 12:
             month = 6;
             break;
         }


             year = year + month;
             year = year + d;


        if(( y > 1900 ) && ( y % 4 == 0 ) && ( m < 2 ) )
         year--;


         day = year % 7;


        if(day == 1)
            return 1;
        else
            return 0;


    }






    void listaDomingoDosRequisitantes(int ano, HASHING *hashingDist) /** Vamos receber o ano que quer para aniversarios, se o ano for 0 entao será para mostrar datas de nascimento - Exercicio 4m */
    {



    NODO_HASHING *nodoHahing = hashingDist->inicio; /** Buscar a primeira cidade da lista */


    if(ano != 0)
        {
            printf("\n-------------- Lista de requisitantes que no ano %d cujo aniversário é num domingo --------------",ano);
        }

    if(ano == 0)
        {
            printf("\n-------------- Lista de requisitantes que nasceram num domingo --------------",ano);
        }






    while(nodoHahing) /** Enquanto houver distritos */
    {
        NODO *aux = nodoHahing->lista->inicio; /** Buscar o primeiro requisitante da cidade */

        while(aux) /** Enquanto houver requisitantes naquele distrito */
        {
            REQUISITANTE *informacoes = aux->info;

            if(ano != 0) /**  Lista de requisitantes que fazem aniversário nesse ano num domingo */
            {
                /**  Se a função devolver 1 significa que o requisitante nesse ano o aniversário é num domingo */
                if(devolverDomingo(informacoes->diaNasc,informacoes->mesNasc,ano) == 1)
                {
                    printf("\n\t %s %d %d %d.",informacoes->nome,informacoes->diaNasc,informacoes->mesNasc,ano);
                }

            }

            if(ano == 0) /**  Lista de requisitantes que nasceram num domingo */
            {
                /**  Se a função devolver 1 significa que o requisitante nasceu num domingo */
                if(devolverDomingo(informacoes->diaNasc,informacoes->mesNasc,informacoes->anoNasc) == 1)
                {
                    printf("\n\t %s %d %d %d.",informacoes->nome,informacoes->diaNasc,informacoes->mesNasc,informacoes->anoNasc);
                }


            }
            aux = aux->seg; /** Requisitante seguinte */
        }
        nodoHahing = nodoHahing->seg;  /**Distrito seguinte */
    }
}

/** ---------- VERIFICAR SE EXISTE O REGISTO DO SOBRENOME, DANDO UM SOBRENOME ---------- */

SOBRENOME *existeSobrenome(LISTA *listaSobrenomes, char *nome)
{
    if(!listaSobrenomes)
        return NULL;

    if(!nome)
        return NULL;

    NODO *aux = listaSobrenomes->inicio;

    while(aux) /* Percorrer todos os sobrenomes */
    {
        SOBRENOME *sobreN = aux->info;
        char *nomeExistente = sobreN->sobrenome;

        if(strcmp(nomeExistente, nome) == 0)
            return sobreN;
        aux = aux->seg;
    }
    return NULL;
}

/** ---------- LISTAR TODOS OS SOBRENOMES ---------- */

SOBRENOME *devolverMaisUsado(LISTA *listaSobrenomes)
{
    if(!listaSobrenomes)
    {
        printf("\n>> A lista de sobrenomes não existe\n");
        return NULL;
    }

    if(!listaSobrenomes->inicio)
    {
        printf("\n>> A lista de sobrenomes está vazia (0 requisitantes)\n");
        return NULL;
    }
    NODO *nodo = listaSobrenomes->inicio;
    SOBRENOME *maisUsado = nodo->info;

    while(nodo)
    {
        SOBRENOME *sobrenome = nodo->info;
        if(sobrenome->nel > maisUsado->nel)
            maisUsado = nodo->info;
        nodo = nodo->seg;
    }
    return maisUsado;
}

/** ---------- DESTRUIR SOBRENOME ---------- */

void destruirSobrenome(void *sobrenome)
{
    if(!sobrenome)
    {
        printf("\n>> Ocorreu um erro na leitura do sobrenome\n");
        return;
    }

    SOBRENOME *sobreN = (SOBRENOME *)sobrenome;
    free(sobreN->sobrenome);
    free(sobreN);
}

/** ---------- DETERMINAR O SOBRENOME MAIS UTILIZADO PELOS REQUISITANTES ---------- */

SOBRENOME *determinarSobrenomeMaisUsado(HASHING *hashingDist)
{
    if(!hashingDist)
    {
        printf("\n>> O hashing de distritos não existe\n");
        return NULL;
    }

    if(!hashingDist->inicio)
    {
        printf("\n>> O hashing de distritos está vazio (0 requisitantes)\n");
        return NULL;
    }
    LISTA *listaSobreNomes = criarLista();
    NODO_HASHING *nodoHashing = hashingDist->inicio;
    char *elemento;
    char *antElemento;

    while(nodoHashing)
    {
        NODO *nodo = nodoHashing->lista->inicio;

        while(nodo)
        {
            REQUISITANTE *req = nodo->info;

            elemento = strtok(req->nome, " ");

            while(elemento != NULL)
            {
                strcpy(antElemento, elemento);
                elemento = strtok(NULL, " ");
            }
            SOBRENOME *encontrado = existeSobrenome(listaSobreNomes, antElemento);

            if(encontrado)
                encontrado->nel++;

            else
            {
                NODO *nodoSobrenome = criarNodo();
                nodoSobrenome->info = (SOBRENOME *)malloc(sizeof(SOBRENOME));
                SOBRENOME *sobreNome = nodoSobrenome->info;

                sobreNome->sobrenome = (char *)malloc((strlen(antElemento) + 1) * sizeof(char));
                strcpy(sobreNome->sobrenome, antElemento);
                sobreNome->nel = 1;

                inserirInicio(listaSobreNomes, nodoSobrenome);
            }
            nodo = nodo->seg;
        }
        nodoHashing = nodoHashing->seg;
    }
    SOBRENOME *sobrenomeADevolver = devolverMaisUsado(listaSobreNomes);

    destruirLista(listaSobreNomes, destruirSobrenome);
    listaSobreNomes = NULL;
    return sobrenomeADevolver;
}

/** ---------- IDADE COM MAIS REQUISITANTES ---------- */

void IdadeComMaisResquesitantes(HASHING *hashingDist)
{
    int guardarValores[100];
    int idade, j, idadeLimitadora, jmax = 0, totalReq = 0, max = 0;

    if(!hashingDist)
    {
        printf("\n>> O hashing de distritos não existe\n");
        return 0;
    }

    if(!hashingDist->inicio)
    {
        printf("\n>> O hashing de distritos está vazio (0 requisitantes)\n");
        return 0;
    }
    NODO_HASHING *nodoHashing = hashingDist->inicio;

    for(j = 0; j < 100; j++)
        guardarValores[j] = 0;

    while(nodoHashing) /* Enquanto houver distritos */
    {
        NODO *auxReq = nodoHashing->lista->inicio; /* Buscar o primeiro requisitante do distrito */

        while(auxReq) /* Enquanto houver requisitantes naquele distrito */
        {
            idade = calcularIdade((REQUISITANTE *)auxReq->info);

            guardarValores[idade]+= 1;
            auxReq = auxReq->seg;
        }
        nodoHashing = nodoHashing->seg;
    }

    for(j = 0; j < 100; j++)
    {
        if(guardarValores[j]>max)
        {
            jmax = j;
            max = guardarValores[j];
        }
    }
    printf("A idade com mais requesitantes é %d e há %d requesitantes com essa idade", jmax ,max);
}


